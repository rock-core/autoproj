#! /usr/bin/env ruby

if RUBY_VERSION < "1.8.7"
    STDERR.puts "autoproj requires Ruby >= 1.8.7"
    exit 1
end

require 'autoproj'
require 'autoproj/autobuild'
require 'open-uri'
require 'autoproj/cmdline'

include Autoproj

InputError = Autoproj::InputError

def color(*args)
    Autoproj.color(*args)
end

def report
    Autobuild::Reporting.report do
        yield
    end
    Autobuild::Reporting.success

rescue ConfigError => e
    STDERR.puts
    STDERR.puts color(e.message, :red, :bold)
    if Autoproj.in_autoproj_installation?(Dir.pwd)
        root_dir = /^#{Regexp.quote(Autoproj.root_dir)}(?!\/\.gems)/
        e.backtrace.find_all { |path| path =~ root_dir }.
            each do |path|
                STDERR.puts color("  in #{path}", :red, :bold)
            end
    end
    if Autobuild.debug then raise
    else exit 1
    end
rescue Interrupt
    STDERR.puts
    STDERR.puts color("Interrupted by user", :red, :bold)
    if Autobuild.debug then raise
    else exit 1
    end
end

Autoproj::OSDependencies.autodetect_ruby

# Check the first element of ARGV. If a tool called autoproj-VALUE exists, just
# pass the hand to it
prefix = File.expand_path(__FILE__)
if File.file?("#{prefix}-#{ARGV.first}")
    binary = "#{prefix}-#{ARGV.shift}"
    # RubyGems have a BIG performance problem when $LOADED_PATH starts to be
    # big. 
    #
    # So, if the sub-script is Ruby-based, just load it and exit
    if File.readlines(binary).first =~ /ruby/
        load binary
        exit
    else
        exec(binary, *ARGV)
    end
end

# Find the autoproj root dir
report do
    selected_packages =
        begin Autoproj::CmdLine.parse_arguments(ARGV.dup)
        rescue RuntimeError => e
            if Autoproj::CmdLine.bootstrap? && !Autoproj.in_autoproj_installation?(Dir.pwd)
                STDERR.puts <<EOTEXT


#{color('autoproj bootstrap failed', :red, :bold)}
To retry, first source the #{Autoproj::ENV_FILENAME} script with
  source #{Dir.pwd}/#{Autoproj::ENV_FILENAME}
and then re-run autoproj bootstrap with
  autoproj bootstrap <vcs_type> <vcs_url> <vcs_options>

where
  'vcs_type' is git, svn, darcs, cvs
  'vcs_url' is the vcs-specific URL to the repository, and
  'vcs_options' are optional values that can be given to the chosen VCS
EOTEXT
            end
            raise
        end

    # Expand directories in the selected_packages set, before we chdir to the
    # autoproj root
    root_dir = Autoproj.root_dir
    selected_packages.map! do |name|
        if File.directory?(name)
            File.expand_path(name) + File::SEPARATOR
        else
            name
        end
    end

    needs_update_config = false
    selected_packages.delete_if do |name|
        if name =~ /^#{Regexp.quote(Autoproj.config_dir + File::SEPARATOR)}/ ||
            name =~ /^#{Regexp.quote(Autoproj.remotes_dir + File::SEPARATOR)}/
            needs_update_config = true
        end
    end

    Dir.chdir(root_dir)

    # Basic initialization
    Autoproj::CmdLine.initialize
    if needs_update_config
        Autoproj::CmdLine.update_configuration
        if selected_packages.empty?
            exit 0
        end
    elsif selected_packages.empty?
        Autoproj::CmdLine.update_myself
        Autoproj::CmdLine.update_configuration
    else
        begin
            old_value = Autobuild.do_update
            Autobuild.do_update = false
            Autoproj::CmdLine.update_configuration
        ensure
            Autobuild.do_update = old_value
        end
    end
    Autoproj::CmdLine.load_configuration
    manifest = Autoproj.manifest

    # Once thing left to do: handle the Autoproj.auto_update configuration
    # parameter
    #
    # Namely, we must check if Autobuild.do_update has been explicitely set to
    # true or false. If that is the case, don't do anything. Otherwise, set it
    # to the value of Autoproj.auto_update
    if Autobuild.do_update.nil?
        Autobuild.do_update = Autoproj.auto_update?
    end

    Autoproj::CmdLine.setup_all_package_directories
    # resolve_user_selection auto-adds packages present on disk but not listed
    # in the manifest. However, since we have not yet loaded overrides /
    # package blocks, it is possible that it contains excluded / ignored
    # packages
    #
    # First do the resolution to get auto-add, finalize the package
    # configuration, and then re-resolve
    Autoproj.silent do
        Autoproj::CmdLine.resolve_user_selection(selected_packages)
    end
    # Now load the rest of the configuration
    Autoproj::CmdLine.finalize_package_setup
    # Finally, filter out exclusions
    resolved_selected_packages = Autoproj::CmdLine.resolve_user_selection(selected_packages)
    Autoproj::CmdLine.validate_user_selection(selected_packages, resolved_selected_packages)

    if !selected_packages.empty?
        command_line_selection = resolved_selected_packages.dup
    else
        command_line_selection = Array.new
    end
    Autoproj.manifest.explicit_selection = resolved_selected_packages
    selected_packages = resolved_selected_packages

    # If in verbose mode, or if we only update sources, list the sources
    if Autoproj.verbose || Autoproj::CmdLine.display_configuration?
        Autoproj::CmdLine.display_configuration(manifest, selected_packages.packages)
    end
    
    if Autoproj::CmdLine.bootstrap?
        STDERR.puts <<EOTEXT


#{color('autoproj bootstrap successfully finished', :green, :bold)}

#{color('To further use autoproj and the installed software', :bold)}, you
must add the following line at the bottom of your .bashrc:
  source #{Dir.pwd}/#{Autoproj::ENV_FILENAME}

WARNING: autoproj will not work until your restart all
your consoles, or run the following in them:
  $ source #{Dir.pwd}/#{Autoproj::ENV_FILENAME}

#{color('To import and build the packages', :bold)}, you can now run
  autoproj update
  autoproj build

The resulting software is installed in
  #{Dir.pwd}/install

EOTEXT
    end

    if Autoproj::CmdLine.only_config? || Autoproj::CmdLine.reconfigure?
        exit(0)
    end

    if Autoproj::CmdLine.only_status?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        result = Autoproj::CmdLine.status(all_enabled_packages)
        if Autoproj::CmdLine.status_exit_code?
            code = 0
            if result.uncommitted
                code |= 1
            end
            if result.local
                code |= 2
            end
            if result.remote
                code |= 4
            end
            exit(code)
        else
            exit(0)
        end
    elsif Autoproj::CmdLine.check?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.check(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.manifest_update?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.manifest_update(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.snapshot?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.snapshot(Autoproj::CmdLine.snapshot_dir, all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.revshow_osdeps?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.revshow_osdeps(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.show_osdeps?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.show_osdeps(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.list_unused?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.list_unused(all_enabled_packages)
        exit(0)
    end

    STDERR.puts
    STDERR.puts color("autoproj: importing and loading selected packages", :bold)

    # Install prepackaged dependencies needed to import and build the packages.
    # The required information is in the package sets configuration.
    if Autoproj::CmdLine.update_os_dependencies?
        Autoproj.osdeps.install(Autoproj.build_system_dependencies)
    end

    # Now, we actually do the import. Unfortunately, at this stage, we need to
    # import the package and its dependencies ourselves so that we are able to
    # build the list of packages that have actually been selected on the command
    # line.
    all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
    Autoproj::CmdLine.load_all_available_package_manifests

    if Autoproj::CmdLine.update_os_dependencies? && !all_enabled_packages.empty?
        begin
            update_mode = Autobuild.do_update
            Autobuild.do_update ||= Autoproj::CmdLine.osdeps?
            manifest.install_os_dependencies(all_enabled_packages)
        ensure
            Autobuild.do_update = update_mode
        end
    end

    if all_enabled_packages.empty?
        STDERR.puts color("autoproj: nothing to do", :bold)
    elsif Autoproj::CmdLine.doc?
        Autoproj::CmdLine.build_packages(command_line_selection, all_enabled_packages)
    elsif Autoproj::CmdLine.build? 
        Autoproj::CmdLine.build_packages(command_line_selection, all_enabled_packages)
    end

    if Autoproj::CmdLine.update_envsh?
        Autoproj.export_env_sh
        Autoproj.message "autoproj: updated #{Autoproj.root_dir}/#{Autoproj::ENV_FILENAME}", :green
    end

    if Autoproj::CmdLine.show_statistics?
        per_phase = Hash.new
        per_type  = Hash.new

        Autoproj.message
        Autoproj.message "statistics about the build", :bold

        Autoproj.manifest.each_package.sort_by(&:name).each do |pkg|
            next if pkg.statistics.empty?

            if per_phase.empty?
                Autoproj.message "detailed per package"
            end

            puts "  #{pkg.name}: %.1fs" % [pkg.statistics.values.inject(&:+)]
            pkg.statistics.each_key.sort.each do |phase|
                per_phase[phase] ||= 0
                per_phase[phase] += pkg.statistics[phase]
                per_type[pkg.class] ||= Hash.new
                per_type[pkg.class][phase] ||= 0
                per_type[pkg.class][phase] += pkg.statistics[phase]
                puts "    #{phase}: %.1fs" % [pkg.statistics[phase]]
            end
        end

        if !per_type.empty?
            Autoproj.message
            Autoproj.message "detailed per package type"
            per_type.each do |pkg_type, phases|
                Autoproj.message "  #{pkg_type.name}: %.1fs" % [phases.values.inject(&:+)]
                phases.each_key.sort.each do |phase_name|
                    Autoproj.message "    #{phase_name}: %.1fs" % [phases[phase_name]]
                end
            end
        end

        if !per_phase.empty?
            Autoproj.message
            Autoproj.message "summary per phase"
            per_phase.keys.sort.each do |phase_name|
                Autoproj.message "  #{phase_name}: %.1fs" % [per_phase[phase_name]]
            end
        end
    end
end

